import sys
import argparse
import os.path
import shutil
import warnings
import datetime
from zipfile import ZipFile
import pickle

import numpy as np
import matplotlib.pyplot as plt
import healpy as hp
from scipy.constants import speed_of_light as c

from pygdsm import HaslamObserver, GSMObserver08
from pygdsm import GSMObserver16
from pygdsm.lfsm import LFSMObserver
from pygdsm.gsm16 import K_CMB2MJysr
from pygdsm.base_observer import BaseObserver

from casacore.measures import measures

from ilisa.calim.geodesy import ITRF2lonlat, utcpos2lmst, lonlat2flt
import ilisa.operations.modeparms as modeparms
import ilisa.operations.data_io as data_io
from . import USER_DATA_DIR
from .imaging import plotskyimage, imggrid_res, fiducial_image,\
    integrate_lm_image
from .visibilities import cov_polidx2flat, calc_uvw, rot2uv,\
    point_source_vis2d, layout_abs2rel
from .beam import horizontaldipoles_jones, jones2cov_patt
from .im_process import n_from_lm


class CommonGSMObs(BaseObserver):
    def __init__(self, gsm_instance):
        """Initialize the common Observer object with a GSM instance
        Calls ephem.Observer.__init__ function and adds on gsm
        """
        super(BaseObserver, self).__init__()
        self.observed_sky = None
        self.gsm = gsm_instance
        # Inline replacement of self._setup() follows.
        # Generate mapping from pix <-> angles
        fu = gsm_instance.freq_unit
        self._freq = 100  # MHz
        if fu == 'Hz':
            self._freq = 100e6
        elif fu == 'GHz':
            self._freq = 0.1
        self.gsm.generate(self._freq)
        self._n_pix  = hp.get_map_size(self.gsm.generated_map_data)
        self._n_side = hp.npix2nside(self._n_pix)
        self._theta, self._phi = hp.pix2ang(self._n_side, np.arange(self._n_pix))


def globaldiffuseskymodel(dattim, geopos, freq, gs_model='LFSM', imsize=200):
    """\
    Generate hemisphere sky model image based on GSM, epoch & geolocation

    Parameters
    ----------
    dattim: datetime
        Epoch for model sky
    geopos: tuple
        Longitude, latitude, elevation tuple of geographic position for model
    freq: float
        Frequency for which model should be generated
    gs_model: str
        ID of global sky model
    imsize: int
        Number of pixels along one dimension of image

    Returns
    -------
    img: array_like
        The image of the Stokes I sky model.
    """
    if freq < 10e6:
        warnings.warn('Freq =< 10 MHz, will use model for 10.1 MHz instead.')
        freq = 10.1e6
    (longitude, latitude, elevation) = geopos
    include_cmb = True
    res = 'hi'
    freq_unit = 'Hz'  # ('Hz', 'MHz', 'GHz')
    # `data_unit` internal to PyGDSM depends on model:
    #       'K' for LFSM, Haslam, GSM08;
    #       'MJysr' for GSM16 (but provides 2 conversion functions to K).
    # so for conformity use default 'K' and then convert afterwards
    data_unit = 'K'  # ('K' default, 'TCMB', 'MJysr', 'TRJ')
    convert_data_unit = 1.
    if data_unit == 'MJysr':
        convert_data_unit = 1.0/K_CMB2MJysr(1., freq)
    if gs_model =='LFSM':
        gsm_obs = LFSMObserver()
    elif gs_model == 'Haslam':
        gsm_obs = HaslamObserver()
    elif gs_model == 'GSM' or gs_model == 'GSM2008' or gs_model == 'GSM08':
        #gsm = GlobalSkyModel08(freq_unit=freq_unit,
        #                     basemap='haslam',  # 'haslam', 'wmap' or '5deg'
        #                     interpolation='pchip'  # 'cubic' or 'pchip'
        #                     )
        gsm_obs = GSMObserver08()
        basemap = 'haslam'
        if freq > 1e6:
            basemap = 'wmap'
        if res != 'hi':
            basemap = '5deg'
        gsm_obs.gsm.basemap = basemap
    else:
        #gsm = GlobalSkyModel16(freq_unit=freq_unit,
        #                         data_unit='MJysr',  # ('TCMB', 'MJysr', 'TRJ')
        #                         resolution='hi',  # ('hi', 'lo')
        #                         theta_rot=0, phi_rot=0)
        gsm_obs = GSMObserver16()
        gsm_obs.gsm.resolution = res
        gsm_obs.gsm.data_unit = 'TCMB'
    # NOTE: CommonGSMObserver() is my addition to PyGDSM
    #gsm_obs = CommonGSMObs(gsm)
    gsm_obs.gsm.freq_unit = freq_unit
    gsm_obs.gsm.include_cmb = include_cmb
    gsm_obs.lon = str(longitude)
    gsm_obs.lat = str(latitude)
    gsm_obs.elev = elevation
    gsm_obs.date = dattim
    try:
        gsm_map = gsm_obs.generate(freq)
    except RuntimeError as e:
        raise ValueError(e)
    # Convert to data_unit
    gsm_map *= convert_data_unit
    img = hp.orthview(gsm_map, half_sky=True, return_projected_map=True,
                      rot=(0, 0), xsize=imsize, norm=None, coord=['C'],
                      flip='geo')  # Use 'geo' since plotskyimage() assumes this
    plt.close(plt.gcf())  # close figure generated by orthview()
    img = np.ma.getdata(img)
    img[img == -np.inf] = 0.0
    return img


class HemiDiffuseSkyModel:
    # Sky Model Image lookup-tables:
    IMAGEMODELTABLE_SUBDIR = 'siddaymodcubes'
    IMAGECUBE_FILE = 'imagecubes.npy'
    DELTASEC_FILE = 'delta_secs.npy'
    FREQS_FILE = 'freqs.npy'
    GEOPOS_FILE = 'geopos.npy'
    HDSM_FILE = 'HDSM.pkl'
    _gsminc = ['name', 'basemap', 'freq_unit', 'data_unit', 'nside',
               'include_cmb']

    def __init__(self, geopos, gs_model='LFSM', imsize=128):
        """\
        Generate hemisphere sky model image based on GSM, epoch & geolocation

        Parameters
        ----------
        geopos: tuple
            Longitude, latitude, elevation tuple of geographic position for model.
            This is a static variable and if it is equal to previous call, it will
            reuse previous instance of GDSM with same geopos, otherwise a new
            instance is created. If None, the gdsm model obj is renewed and None
            is returned.
        gs_model: str
            ID of global sky model
        imsize: int
            Number of pixels along one dimension of image
        """
        self.geopos = geopos
        self.gs_model = gs_model
        self.imsize = imsize
        self._uselookuptab = False
        # When geopos is tuple, calculate directly from model
        # Initialize calc model object (self.gsm_obs)
        gs_model = self.gs_model
        (longitude, latitude, elevation) = self.geopos
        include_cmb = True
        res = 'hi'
        freq_unit = 'Hz'  # ('Hz', 'MHz', 'GHz')
        # `data_unit` internal to PyGDSM depends on model:
        #       'K' for LFSM, Haslam, GSM08;
        #       'TCMB' for GSM16 (but provides 2 conversion functions to K).
        # so for conformity use default 'K' and then convert afterwards
        if gs_model == 'LFSM':
            gsm_obs = LFSMObserver()
        elif gs_model == 'Haslam':
            gsm_obs = HaslamObserver()
        elif gs_model == 'GSM' or gs_model == 'GSM2008' or gs_model == 'GSM08':
            # gsm = GlobalSkyModel08(freq_unit=freq_unit,
            #                     basemap='haslam',  # 'haslam', 'wmap' or '5deg'
            #                     interpolation='pchip'  # 'cubic' or 'pchip'
            #                     )
            gsm_obs = GSMObserver08()
            basemap = 'haslam'
            if res != 'hi':
                basemap = '5deg'
            gsm_obs.gsm.basemap = basemap
        else:
            # gsm=GlobalSkyModel16(freq_unit=freq_unit,
            #                     data_unit='TCMB',  # ('TCMB','MJysr','TRJ')
            #                     resolution='hi',  # ('hi', 'lo')
            #                     theta_rot=0, phi_rot=0)
            gsm_obs = GSMObserver16()
            gsm_obs.gsm.resolution = res
        gsm_obs.gsm.freq_unit = freq_unit
        gsm_obs.gsm.include_cmb = include_cmb
        gsm_obs.lon = str(longitude)
        gsm_obs.lat = str(latitude)
        gsm_obs.elev = elevation
        self.gsm_obs = gsm_obs

    def generate_siddaymodcubes(self, freqs, nrtime=144, filename=None):
        """\
        Generate all possible sky model cubes for a location

        Parameters
        ----------
        geopos : tuple
            Geoposition tuple given as (lon, lat) or (lon, lat, hgt).
        freqs : list
            List of frequencies in Hz.
        nrtime : int
            Number of sidereal time samples.
        filename : str
            Basename of memmap file to output. If `None` then use normal
            variable for storage.

        Returns
        -------
        allskies : array
            Model direction-cosine cubes for all sidereal times (starting at
            LMST 00:00:00). Array indices: [t_idx, freq_idx, l_idx, m_idx].
            If `filename` is given, this array will be a memmapped array in file
            named '<filename>.npy'.
        """
        from numpy.lib.format import open_memmap
        geopos_flt = lonlat2flt(self.geopos)
        lon = geopos_flt[0]
        # Use datetime 2000-01-01T17:17:17 UTC since it corresponds to 00:00:00 GMST
        start_dattim_GM = datetime.datetime(2000, 1, 1, 17, 17, 17)
        sid2ut = 365.24 / 366.24
        start_dattim = start_dattim_GM - datetime.timedelta(days=lon / 360) * sid2ut
        del_ts = np.arange(
            nrtime) / nrtime * 24 * 60 * 60  # time since `start_dattim` in s
        nrfreq = len(freqs)
        nrdel_ts = len(del_ts)
        if filename:
            cwd = os.getcwd()
            filesfolder = os.path.join(USER_DATA_DIR, HemiDiffuseSkyModel.IMAGEMODELTABLE_SUBDIR)
            os.chdir(filesfolder)
            imcub_file = HemiDiffuseSkyModel.IMAGECUBE_FILE
            imcub = open_memmap(imcub_file + '', dtype='float32', mode='w+',
                                shape=(nrdel_ts, nrfreq, self.imsize, self.imsize))
        else:
            imcub = np.zeros((nrdel_ts, nrfreq, self.imsize, self.imsize))
        for freq_idx in range(nrfreq):
            print('frq', freq_idx, '/', nrfreq)
            for t_idx in range(nrdel_ts):
                print('Simulating timestep ', t_idx, '/', nrdel_ts, end='\r')
                dattim = start_dattim + datetime.timedelta(seconds=int(del_ts[t_idx]))
                img0 = self.get_image(dattim, freqs[freq_idx])
                imcub[t_idx, freq_idx, ...] = img0
            print()
        if filename:
            deltasecs_file = HemiDiffuseSkyModel.DELTASEC_FILE
            np.save(deltasecs_file, del_ts)
            freqs_file = HemiDiffuseSkyModel.FREQS_FILE
            np.save(freqs_file, freqs)
            geopos_file = HemiDiffuseSkyModel.GEOPOS_FILE
            np.save(geopos_file, self.geopos)
            imcub.flush()
            hdsm_file = HemiDiffuseSkyModel.HDSM_FILE
            pklvars = {}
            for k in self._gsminc:
                pklvars[k] = getattr(self.gsm_obs.gsm, k)
            with open(hdsm_file, 'wb') as pf:
                pickle.dump(pklvars, pf)
            with ZipFile(filename + '.npz', 'w') as z:
                z.write(imcub_file)
                z.write(deltasecs_file)
                z.write(freqs_file)
                z.write(geopos_file)
                z.write(hdsm_file)
            os.remove(imcub_file)
            os.remove(deltasecs_file)
            os.remove(freqs_file)
            os.remove(geopos_file)
            os.remove(hdsm_file)
            os.chdir(cwd)
        return imcub

    @classmethod
    def load_siddaymodcubes(cls, modelfile):
        """\
        Load a Sidereal Day Model Cube file

        Parameters
        ----------
        modelfile : str
            Name of the Sidereal Day Model Cube file. This is a zipped file
            containing numpy files for the imagecube, freqs, deltasecs, geopos.

        Returns
        -------
        hdsm_tab : HemiDiffuseSkyModel
            The HemiDiffuseSkyModel corresponding to `modelfile`.
        """
        # `modelfile` is name of lookup-table, it lives under the USER_DATA_DIR
        cwd = os.getcwd()
        os.chdir(os.path.join(USER_DATA_DIR,
                              HemiDiffuseSkyModel.IMAGEMODELTABLE_SUBDIR))
        # Initialize lookup table (in particular self.tab_imagecube):
        print("Initializing image lookup tables II")
        with ZipFile(modelfile + '.npz') as _zf:
            _zf.extractall()
        tab_imagecube = np.load(HemiDiffuseSkyModel.IMAGECUBE_FILE)
        freqs = np.load(HemiDiffuseSkyModel.FREQS_FILE)
        deltasecs = np.load(HemiDiffuseSkyModel.DELTASEC_FILE)
        geopos = tuple(np.load(HemiDiffuseSkyModel.GEOPOS_FILE).tolist())
        with open(HemiDiffuseSkyModel.HDSM_FILE,'rb') as pf:
            gsm = pickle.load(pf)
        # Now that model data has been loaded remove unzipped files:
        for fn in [HemiDiffuseSkyModel.IMAGECUBE_FILE,
                   HemiDiffuseSkyModel.FREQS_FILE,
                   HemiDiffuseSkyModel.DELTASEC_FILE,
                   HemiDiffuseSkyModel.GEOPOS_FILE,
                   HemiDiffuseSkyModel.HDSM_FILE]:
            os.remove(fn)
        os.chdir(cwd)
        # Create HemiDiffuseSkyModel instance which uses lookup table:
        imsize = tab_imagecube.shape[-1]
        hdsm_tab = cls(geopos, imsize=imsize)
        hdsm_tab._uselookuptab = True
        hdsm_tab.freqs = freqs
        hdsm_tab.deltasecs = deltasecs
        hdsm_tab.tab_imagecube = tab_imagecube
        for k in cls._gsminc:
            setattr(hdsm_tab.gsm_obs.gsm , k, gsm[k])
        return hdsm_tab

    def get_image(self, dattim, freq):
        """
        Get Stokes I model image for date-time and frequency

        Parameters
        ----------
        dattim: datetime
            Epoch for model sky
        freq: float
            Frequency for which model should be generated

        Returns
        -------
        img0: array_like
            The image of the Stokes I sky model.
        """
        if freq < 10e6:
            warnings.warn('Freq =< 10 MHz, will use model for 10.1 MHz instead.')
            freq = 10.1e6

        if self._uselookuptab:
            img0 = self._image_lookup(dattim, freq)
        else:
            # Set attrs that could not be set but now freq is specified:
            if (type(self.gsm_obs) == GSMObserver08
                    and self.gsm_obs.gsm.basemap != '5deg') and freq > 1e6:
                self.gsm_obs.gsm.basemap = 'wmap'
            img0 = self._image_calc(dattim, freq)
        return img0

    def _image_lookup(self, dattim, freq):
        """\
        """
        frq_idx = (np.abs(self.freqs - freq)).argmin()
        geopos_str = (str(self.geopos[0]) + 'deg', str(self.geopos[1]) + 'deg',
                      str(self.geopos[2]) + 'm')
        lmst_sec = utcpos2lmst(dattim, geopos_str)
        # Using nearest-neighbor interpolation
        # so find lookup time closest to requested time
        t_idx = (np.abs(self.deltasecs - lmst_sec)).argmin()
        img0 = self.tab_imagecube[t_idx, frq_idx, :, :].squeeze()
        return img0

    def _image_calc(self, dattim ,freq):
        """\
        """
        gsm_obs = self.gsm_obs
        gsm_obs.date = dattim
        gsm_obs.observed_sky = None  #
        try:
            gsm_map = gsm_obs.generate(freq)
        except RuntimeError as e:
            raise ValueError(e)
        # Convert to data_unit
        data_unit = 'K'  # ('K' default, 'TCMB', 'MJysr', 'TRJ')
        convert_data_unit = 1.
        if data_unit == 'MJysr':
            convert_data_unit = 1.0 / K_CMB2MJysr(1., freq)
        gsm_map *= convert_data_unit
        img = hp.orthview(gsm_map, half_sky=True, return_projected_map=True,
                          rot=(0, 0), xsize=self.imsize, norm=None, coord=['C'],
                          flip='geo')  # Use 'geo' since plotskyimage() assumes this
        plt.close(plt.gcf())  # close figure generated by orthview()
        img = np.ma.getdata(img)
        img[img == -np.inf] = 0.0
        return img


def plot_gsm_for_obsdata(cvcobj, filenr=0, sampnr=0, gs_model='LFSM',
                         imsize=200):
    stnid = cvcobj.scanrecinfo.get_stnid()
    for fileidx in range(filenr, cvcobj.getnrfiles()):
        intgs = len(cvcobj.samptimeset[fileidx])
        for tidx in range(sampnr, intgs):
            dattim = cvcobj.samptimeset[fileidx][tidx]
            freq = cvcobj.freqset[fileidx][tidx]
            lon, lat, h = ITRF2lonlat(cvcobj.stn_pos[0, 0],
                                      cvcobj.stn_pos[1, 0],
                                      cvcobj.stn_pos[2, 0])
            skyimg_model = globaldiffuseskymodel(dattim, (lon, lat, h),
                                                 freq, gs_model=gs_model,
                                                 imsize=imsize)
            l, m = np.linspace(-1, 1, imsize), np.linspace(-1, 1, imsize)
            ll, mm = np.meshgrid(l, m)
            img_zero = np.zeros_like(skyimg_model, dtype=float)
            modality = 'model:'+gs_model
            _phaseref_ = (0, np.pi/2,'AZEL')
            integration = None
            correctpb = True
            fluxperbeam = False
            plotskyimage(ll, mm, (skyimg_model, img_zero, img_zero, img_zero),
                         'stokes', dattim, freq, stnid, integration, _phaseref_,
                         modality, pbcor=correctpb, maskhrz=False,
                         fluxperbeam=fluxperbeam, plot_title='Model image')
            plt.show()


def vcz(ll, mm, skyimage, freq, ant_pos, imag_is_fd=False):
    """\
    Compute visibility from image via the van Cittert-Zernicke relation

    Parameters
    ----------
    ll : array_like
        Direction cosine, x-aligned image coordinate.
    mm : array_like
        Direction cosine, y-aligned image coordinate.
    skyimage : array_like
        Total flux image of sky.
    freq: float
        Center frequency in Hz
    ant_pos: array_like
        Position vectors of array elements
    imag_is_fd : bool
        Input image is flux distribution map (fd) rather than flux density
        distribution (fdd) map.

    Returns
    -------
    vis : array_like
        Visibility corresponding to input skyimage via vCZ relation.
    """
    pos_x = ant_pos[:, 0].squeeze()
    pos_y = ant_pos[:, 1].squeeze()
    pos_z = ant_pos[:, 2].squeeze()

    nr_ants = pos_x.shape[0]
    vis = np.zeros((nr_ants, nr_ants), dtype=complex)
    k = 2 * np.pi * freq / c
    nn = n_from_lm(ll, mm)
    if imag_is_fd:
        fdd = skyimage / nn
    else:
        fdd = skyimage
    dll, dmm = imggrid_res(ll, mm)
    for ant_i in range(nr_ants):
        for ant_j in range(ant_i, nr_ants):
            u = pos_x[ant_i] - pos_x[ant_j]
            v = pos_y[ant_i] - pos_y[ant_j]
            w = pos_z[ant_i] - pos_z[ant_j]
            vis[ant_i, ant_j] = np.sum(
                fdd * np.exp(+1.0j * k * (ll * u + mm * v + (nn-1) * w))
                *dll*dmm)
    do_conj = True
    if do_conj:
        for ant_i in range(nr_ants):
            for ant_j in range(0, ant_i):
                vis[ant_i, ant_j] = np.conj(vis[ant_j, ant_i])
    return vis


def skymodel_visibility(t, stn_pos, freq, stn_antpos, gs_model, ant_model=''):
    """
    Create sky-model visibilities

    Parameters
    ----------
    t: datetime
        Epoch date-time
    stn_pos: array
        Station position on Earth as 3D ITRF vector.
    freq: float
        Frequency of observation in Hz.
    stn_antpos: array [3, N]
        Positions, 3D cartesian, of antennas in array.
    gs_model: str
        Global skymodel name.
    ant_model:
        Name of antenna model. '' for no antenna, or 'dual_dipole45' for dual
        dipoles tilted 45 deg.

    Returns
    -------
    skymod_vis: array
        Complex array of visibilities
    """
    #nr_ants = stn_pos.shape[1]
    imsize = 100  # ToDo: improve this expression?
    l = np.linspace(-1, 1, imsize)
    m = np.linspace(-1, 1, imsize)
    ll, mm = np.meshgrid(l, m)
    stn_pos_x, stn_pos_y, stn_pos_z \
        = stn_pos[0, 0], stn_pos[1, 0], stn_pos[2, 0]
    ccm = measures()
    ccm.doframe(ccm.position('ITRF', str(stn_pos_x) + 'm', str(stn_pos_y) + 'm',
                             str(stn_pos_z) + 'm'))
    lon, lat, h = ITRF2lonlat(stn_pos_x, stn_pos_y, stn_pos_z)
    img_S0 = globaldiffuseskymodel(t, (lon, lat, h), freq,
                                gs_model=gs_model,
                                imsize=imsize)
    ccm.doframe(ccm.epoch('UTC', t.isoformat('T')))
    phaseref_ccm = ccm.measure(
        ccm.direction('AZEL', '0.0rad', str(np.deg2rad(90)) + 'rad'), 'J2000')
    phaseref = (phaseref_ccm['m0']['value'], phaseref_ccm['m1']['value'],
                phaseref_ccm['refer'])
    uvw_sl = calc_uvw(t, phaseref, stn_pos, stn_antpos)
    if ant_model == 'dual_dipole45':
        jones_patt = horizontaldipoles_jones(ll, mm, rotzen=np.pi/2, reff=0.)
        (cov_xx, cov_xy, cov_yx, cov_yy) = jones2cov_patt(jones_patt)
        imag_xx = cov_xx * img_S0 / 2.0
        imag_xy = cov_xy * img_S0 / 2.0
        imag_yx = cov_yx * img_S0 / 2.0
        imag_yy = cov_yy * img_S0 / 2.0
        vis_xx = vcz(ll, mm, imag_xx, freq, uvw_sl, imag_is_fd=False)
        vis_xy = vcz(ll, mm, imag_xy, freq, uvw_sl, imag_is_fd=False)
        vis_yx = vcz(ll, mm, imag_yx, freq, uvw_sl, imag_is_fd=False)
        vis_yy = vcz(ll, mm, imag_yy, freq, uvw_sl, imag_is_fd=False)
    else:
        imag_xx = img_S0 / 2.0
        imag_yy = imag_xx
        vis_xx = vcz(ll, mm, imag_xx, freq, uvw_sl, imag_is_fd=False)
        vis_yy = vis_xx
        vis_xy = np.zeros_like(vis_xx)
        vis_yx = np.zeros_like(vis_xx)
    return vis_xx, vis_xy, vis_yx, vis_yy


def lightcurve_bl(freq, gs_model_obj, t_s=None, start_dattim=None,
                  beampat0=1, beampat1=None):
    """\
    Baseline lightcurve

    Parameters
    ----------
    freq: float
        Frequency in Hertz.
    gs_model_obj : GlobalDiffuseSkyModel
        The global diffuse skymodel object to use.
    t_s: array
        Sample times.
    start_dattim: datetime
        Date-time of first sample.
    beampat0: array
        2D array of float representing the beampattern of
    beampat1: array
        2D array of float representing the beampattern.

    Returns
    -------
    lmsts: array
        Local sidereal times of samples.
    lightcurve: array
        The light-curve values at sample times.
    start_dat00: datetime
        The python datetime.datetime for the start date with time set to
        midnight.
    """
    geopos = gs_model_obj.geopos
    if t_s is None:
        t_s = np.arange(24.)*60*60
    # Convert `start_dattim` instant to python `datetime`
    if type(start_dattim) is str:
        start_dattim = datetime.datetime.strptime(start_dattim,
                                                  '%Y-%m-%dT%H:%M:%S')
    elif type(start_dattim) == np.ndarray:
        start_dattim = datetime64_to_datetime(start_dattim)
    if beampat1 is None:
        beampat1 = beampat0
    if type(beampat0) == np.ndarray:
        # Compute gain wrt Stokes I (ie multiply by S0 brightness for Rx pow)
        beam_S0 = np.einsum('ij...,kj...->ik...', beampat0, np.conj(beampat1))
        #beam_S0 *= 0.5  # Due to Pauli dim of 2 (for Mueller not coherence mat)
        # Assuming unpolarized sky model so brightness matrix is prop to ident
    else:
        imsize = gs_model_obj.imsize
        beam_S0 = np.zeros((2, 2, imsize, imsize))
        isotrsky = np.ones((imsize, imsize))
        beam_S0[0, 0] = beampat0*beampat0*isotrsky
        beam_S0[1, 1] = beampat1*beampat1*isotrsky
    lmsts = []
    # Compute auto-power of each dual-pol channel
    lightcurv00 = []
    lightcurv11 = []
    data_unit = gs_model_obj.gsm_obs.gsm.data_unit
    _use_solidangle = True
    pownrm00 = 1.0
    pownrm11 = 1.0
    # Assume brightness is a temperature rather than spectral flux density
    if data_unit == 'K' or data_unit == 'TCMB' or data_unit == 'TRJ':
        bri_tot2pol = 1.0  # Temperature of pol-comp is same as total
        pownrm00 = integrate_lm_image(beam_S0[0, 0],
                                      use_solidangle=_use_solidangle)
        pownrm11 = integrate_lm_image(beam_S0[1, 1],
                                      use_solidangle=_use_solidangle)
    elif data_unit.endswith('Jy'):
        bri_tot2pol = 0.5  # Flux of pol-comp is half of total
    for dt in t_s:
        print('Simulating timestep ', dt/t_s[1], '/', t_s[-1]/t_s[1], end='\r')
        dattim = start_dattim + datetime.timedelta(seconds=int(dt))
        lst = utcpos2lmst(dattim, geopos)
        bri_mod_S0 = gs_model_obj.get_image(dattim, freq)
        powtot00 = integrate_lm_image(bri_tot2pol * bri_mod_S0 * beam_S0[0, 0],
                                      use_solidangle=_use_solidangle)
        powtot11 = integrate_lm_image(bri_tot2pol * bri_mod_S0 * beam_S0[1, 1],
                                      use_solidangle=_use_solidangle)
        powtot00 /= pownrm00
        powtot11 /= pownrm11
        lmsts.append(lst)
        lightcurv00.append(powtot00)
        lightcurv11.append(powtot11)
    print()
    # From start_dattim compute start_dat00 which is the datetime for the start
    # date with time set to midnight
    start_dat00 = datetime.datetime.combine(start_dattim.date(), datetime.time())
    return np.asarray(lmsts), np.asarray(lightcurv00), np.asarray(lightcurv11),\
           start_dat00


def datetime64_to_datetime(dattim64):
    """\
    Convert datetime64 to python datetime

    Parameters
    ----------
    dattim64 : numpy.datetime64
        A numpy datetime64 date-time.

    Returns
    -------
    dattim : datetime.datetime
        A python datetime date-time.
    """
    dattim = datetime.datetime.utcfromtimestamp(
        (dattim64-np.datetime64('1970-01-01T00:00:00'))/np.timedelta64(1, 's'))
    return dattim


def create_vis_model(visdata_in, gs_model, ant_model=''):
    """
    Create visibility model

    Parameters
    ----------
    visdata_in: dict
        The visibilities dataset. Actual visibility arr not used,
        only metadata on observational setup.
    gs_model: str
        Name of global sky model to use
    ant_model: str
        Name of antenna model to use. Could be '' or 'dual_dipole45'. If empty
        str then no antenna model will be applied.

    Returns
    -------
    visdata: dict
        The model visibilities as a CVCfiles object

    Raises
    ------
    FileExitsError
        If the model filefolder already exists.
    """
    visdata = visdata_in.copy()
    ldat_type = visdata['datatype']
    if ldat_type != 'acc' and ldat_type != 'xst':
        raise ValueError("ldat_type not set")
    # Look for visibility arrays
    arr_keys = list(filter(lambda k: k.startswith('arr_'), visdata.keys()))
    nrfiles = len(arr_keys)
    stn_pos, antpos_uv = layout_abs2rel(visdata['positions'])
    if visdata.get('stn_rot') is not None:
        antpos_uv = rot2uv(antpos_uv, visdata['stn_rot'].T)
    nrants = antpos_uv.shape[0]
    for filestep in range(nrfiles):
        print("Making model for file {}/{}".format(filestep, nrfiles))
        if nrfiles > 1:
            ts = visdata['delta_secs'][filestep]
        else:
            # There 2 cases for nrfiles==1: need to remove singleton
            ts = visdata['delta_secs'].squeeze()
        cvc_infile = np.empty((len(ts), 2, 2, nrants, nrants), dtype=complex)
        for sampstep in range(len(ts)):
            print("  sample {}/{}".format(sampstep, len(ts)), end='\r')
            if ldat_type == "xst":
                if visdata['frequencies'].ndim == 0:
                    freq = visdata['frequencies']  # Freq const. over xst file
            else:
                if nrfiles > 1:
                    freq = visdata['frequencies'][filestep][sampstep]
                else:
                    freq = visdata['frequencies'][sampstep]
            t = datetime64_to_datetime(visdata['start_datetime']
                                       + np.timedelta64(int(ts[sampstep]),'s'))
            if not gs_model.startswith('fid:'):
                vis_XX_mod, vis_XY_mod, vis_YX_mod, vis_YY_mod \
                    = skymodel_visibility(t, np.asmatrix(stn_pos).T, freq,
                                          np.asmatrix(visdata['positions']),
                                          gs_model, ant_model=ant_model)
            else:
                _fid, fid_typ = gs_model.split(':', 1)
                lam = c/freq
                stn_antpos_lambda = antpos_uv / lam
                if fid_typ == 'map':
                    ll, mm, img_I = fiducial_image(background=0.0)
                    # N.B. freq=c => k=2*np.pi since antpos in lambda units
                    # (nominally freq=c/lam)
                    vis_I_mod = vcz(ll, mm, img_I, c, stn_antpos_lambda,
                                    imag_is_fd=False)
                elif fid_typ == 'vis':
                    vis_I_mod = point_source_vis2d(stn_antpos_lambda, l0=0.0,
                                                   m0=0.0, amp=1.0)
                vis_XX_mod = vis_I_mod / 2.0
                vis_YY_mod = vis_I_mod / 2.0
                vis_XY_mod = np.zeros_like(vis_I_mod)
                vis_YX_mod = np.zeros_like(vis_I_mod)
            cvc_infile[sampstep, ...] = np.asarray(
                                           [[vis_XX_mod, vis_XY_mod],
                                            [vis_YX_mod, vis_YY_mod]])
            # Replace observed data with model data:
        visdata[arr_keys[filestep]] = cvc_infile
        print()
    # Note in ScanRecInfo about model for this dataset:
    visdata['model'] = gs_model + '+' + ant_model
    return visdata


def create_vis_model_ff(cvcpath, gs_model, ant_model=''):
    """
    Create visibility model file-folder based on measured data file-folder

    Parameters
    ----------
    cvcpath: str
        Path to measured visibilities
    gs_model: str
        Name of global sky model to use
    ant_model: str
        Name of antenna model to use. Could be '' or 'dual_dipole45'. If empty
        str then no antenna model will be applied.

    Returns
    -------
    cvcobj_mod: CVCfiles
        The model visibilities as a CVCfiles object

    Raises
    ------
    FileExitsError
        If the model filefolder already exists.
    """
    ldat_type = data_io.datafolder_type(cvcpath)
    if ldat_type != 'acc' and ldat_type != 'xst':
        raise ValueError("Not CVC data.")
    # Copy CVC folder within parent folder and add the tag "_cal_" in the name
    # right before ldat_type suffix:
    spltpath = cvcpath.split("_")
    cvcmodpath = "_".join(spltpath[:-1]) + "_mod_" + spltpath[-1]
    if os.path.exists(cvcmodpath):
        raise FileExistsError('Model folder already exists: '+cvcmodpath)
    shutil.copytree(cvcpath, cvcmodpath)
    # Read in as cvcobj model to be:
    cvcobj_mod = data_io.CVCfiles(cvcmodpath)
    nrfiles = cvcobj_mod.getnrfiles()
    antpos_uv = rot2uv(cvcobj_mod.stn_antpos, cvcobj_mod.stn_rot)
    # Loop over files in CVC folder:
    for filestep in range(nrfiles):
        if ldat_type == "xst":
            freq = cvcobj_mod.freqset[filestep][0]  # Freq const. over xst file
            sb, nz = modeparms.freq2sb(freq)
        else:
            sb = None  # Because this signals ACC data
        print("Making model for file {}/{}".format(filestep, nrfiles))
        freqs = cvcobj_mod.freqset[filestep]
        ts = cvcobj_mod.samptimeset[filestep]
        cvc_infile = np.empty((len(ts), cvcobj_mod.cvcdim1,
                               cvcobj_mod.cvcdim2), dtype=complex)
        for sampstep in range(len(ts)):
            print("  sample {}/{}".format(sampstep, len(ts)), end='\r')
            freq = freqs[sampstep]
            t = ts[sampstep]
            if not gs_model.startswith('fid:'):
                vis_XX_mod, vis_XY_mod, vis_YX_mod, vis_YY_mod \
                    = skymodel_visibility(t, cvcobj_mod.stn_pos, freq,
                                          cvcobj_mod.stn_antpos, gs_model,
                                          ant_model=ant_model)
            else:
                _fid, fid_typ = gs_model.split(':', 1)
                lam = c/freq
                stn_antpos_lambda = antpos_uv / lam
                if fid_typ == 'map':
                    ll, mm, img_I = fiducial_image(background=0.0)
                    # N.B. freq=c => k=2*np.pi since antpos in lambda units
                    # (nominally freq=c/lam)
                    vis_I_mod = vcz(ll, mm, img_I, c, stn_antpos_lambda,
                                    imag_is_fd=False)
                elif fid_typ == 'vis':
                    vis_I_mod = point_source_vis2d(stn_antpos_lambda, l0=0.0,
                                                   m0=0.0, amp=1.0)
                vis_XX_mod = vis_I_mod / 2.0
                vis_YY_mod = vis_I_mod / 2.0
                vis_XY_mod = np.zeros_like(vis_I_mod)
                vis_YX_mod = np.zeros_like(vis_I_mod)
            vis_flat_mod = cov_polidx2flat(np.asarray(
                                           [[vis_XX_mod, vis_XY_mod],
                                            [vis_YX_mod, vis_YY_mod]]))
            cvc_infile[sampstep, ...] = vis_flat_mod
            # Replace observed data with model data:
        cvcobj_mod[filestep] = cvc_infile
        print()
    # Note in ScanRecInfo about model for this dataset:
    cvcobj_mod.scanrecinfo.scanrecpath = cvcmodpath
    cvcobj_mod.scanrecinfo.set_model(gs_model+'+'+ant_model)
    return cvcobj_mod


def main_cli():
    """
    Compute a model based on LOFAR visibility datafile

    Resulting model can either be represented as a visibility datafile or as a
    sky image.
    """
    parser = argparse.ArgumentParser(
        description='Compute a model based on LOFAR datafiles.')
    parser.add_argument('rep', type=str,
                        help="Model representation. Choose: 'vis' or 'img'.")
    parser.add_argument('-n', '--filenr', type=int, default=0)
    parser.add_argument('-s', '--sampnr', type=int, default=0)
    parser.add_argument('-f', '--fluxpersterradian', action="store_true",
                        help="Normalize flux per sterradian")
    parser.add_argument('-g', '--gs_model', type=str, default='LFSM',
                        help="Name of global sky model")
    parser.add_argument('-a', '--ant_model', type=str, default='',
                        help="Name of antenna model")
    parser.add_argument('dataff',
                        help="""Path to CVC folder""")
    args = parser.parse_args()
    cvcobj = data_io.CVCfiles(args.dataff)
    if args.rep == 'vis':
        try:
            create_vis_model_ff(args.dataff, args.gs_model, args.ant_model)
        except FileExistsError as e:
            print(e, file=sys.stderr)
            print('Remove it to create a new vis model!', file=sys.stderr)
    elif args.rep == 'img':
        plot_gsm_for_obsdata(cvcobj, args.filenr, args.sampnr, args.gs_model)


if __name__ == "__main__":
    main_cli()
